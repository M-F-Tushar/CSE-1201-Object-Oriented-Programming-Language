# 3.3 RETURNING OBJECTS FROM FUNCTIONS

## Overview
Just as you can pass objects to functions, functions can return objects. To return an object from a function:
1. **Declare the function as returning a class type**
2. **Return an object of that type using the normal return statement**

## Critical Concept: Temporary Objects
**Important:** When an object is returned by a function, a **temporary object** is automatically created which holds the return value. It is this temporary object that is actually returned by the function. After the value has been returned, this temporary object is destroyed.

⚠️ **Warning:** The destruction of this temporary object might cause unexpected side effects in some situations.

---

## Example 1: Basic Object Return (Safe Version)

This example demonstrates the fundamental concept of returning objects from functions:

```cpp
// Returning an object
#include <iostream>
#include <cstring>
using namespace std;

class samp {
    char s[80];
public:
    void show() { cout << s << "\n"; }
    void set(char *str) { strcpy(s, str); }
};

// Return an object of type samp
samp input() {
    char s[80];
    samp str;
    cout << "Enter a string: ";
    cin >> s;
    str.set(s);
    return str;  // Returns a copy of str
}

int main() {
    samp ob;
    // assign returned object to ob
    ob = input();
    ob.show();
    return 0;
}
```

**Step-by-Step Execution:**
1. `input()` creates a local object `str`
2. User input is read and copied into `str.s` using `strcpy()`
3. `return str` creates a temporary copy of `str`
4. The temporary object is returned to `main()`
5. Assignment `ob = input()` copies the temporary object to `ob`
6. The temporary object is destroyed
7. `ob.show()` displays the string

**Why This Works:**
- The class uses a fixed-size array `char s[80]`
- No dynamic memory allocation
- No custom destructor that could cause problems
- Safe copying of data

---

## Example 2: Dangerous Object Return (Memory Management Error)

This example shows what can go wrong when returning objects that manage dynamic memory:

```cpp
// An error generated by returning an object.
#include <iostream>
#include <cstring>
#include <cstdlib>
using namespace std;

class samp {
    char *s;
public:
    samp() { s = '\0'; }
    ~samp() { if(s) free(s); cout << "Freeing s\n"; }
    void show() { cout << s << "\n"; }
    void set(char *str);
};

// Load a string.
void samp::set(char *str) {
    s = (char*) malloc(strlen(str)+1);
    if (!s) {
        cout << "Allocation error\n";
        exit(1);
    }
    strcpy(s, str);
}

// Return an object of type samp
samp input() {
    char s[80];
    samp str;
    cout << "Enter a string: ";
    cin >> s;
    str.set(s);
    return str;  // PROBLEM: Returns copy with same pointer!
}

int main() {
    samp ob;
    // assign returned object to ob
    ob = input();  // This causes an error!!!!
    ob.show();
    return 0;
}
```

**Sample Output:**
```
Enter a string: Hello
Freeing s
Freeing s
Hello
Freeing s
Null pointer assignment
```

**Detailed Problem Analysis:**

### The Three Destructor Calls:
1. **First destructor call**: When local object `str` goes out of scope as `input()` returns
2. **Second destructor call**: When the temporary object (copy of `str`) is destroyed after assignment
3. **Third destructor call**: When object `ob` is destroyed at program termination

### The Memory Problem:
1. **Object Creation**: `str` in `input()` allocates memory for the string
2. **Return Process**: A temporary copy of `str` is created (shallow copy - same pointer value)
3. **First Destruction**: `str` goes out of scope, destructor frees the memory
4. **Second Destruction**: Temporary object's destructor tries to free the same memory (already freed!)
5. **Third Destruction**: `ob`'s destructor tries to free the same memory again
6. **Result**: Memory corruption and "Null pointer assignment" error

### Visual Representation:
```
Memory Address: 0x1000  [Hello\0]
                   ↑
str.s          ----+
temp_obj.s     ----+  (Same pointer!)
ob.s           ----+  (Same pointer!)

After first destructor: Memory freed
After second destructor: Double free error!
After third destructor: Triple free error!
```

---

## Key Concepts and Rules

### Temporary Object Lifecycle:
1. **Creation**: When function returns, temporary object is created
2. **Usage**: Temporary object is used for assignment or initialization
3. **Destruction**: Temporary object is immediately destroyed after use

### Problems with Dynamic Memory:
- **Shallow Copy**: Default copy behavior copies pointer values, not pointed-to data
- **Multiple Destruction**: Same memory freed multiple times
- **Dangling Pointers**: Pointers to freed memory

### Safe Return Scenarios:
- Objects with only automatic storage (stack variables)
- Objects with proper copy constructors
- Objects that don't manage resources
- Simple data types

---

## Exercises

### Exercise 1: Object Construction and Destruction Tracking

**Task:** Create a class called `who` that tracks construction and destruction when objects are returned from functions.

**Requirements:**
- Constructor takes one character argument for identification
- Display "Constructing who #x" when constructing
- Display "Destroying who #x" when destroying
- Create a function `make_who()` that returns a `who` object
- Give each object a unique name

**Solution:**

```cpp
#include <iostream>
using namespace std;

class who {
    char id;
public:
    who(char c) : id(c) {
        cout << "Constructing who #" << id << "\n";
    }
    
    ~who() {
        cout << "Destroying who #" << id << "\n";
    }
    
    // Copy constructor to track copies
    who(const who& other) : id(other.id) {
        cout << "Copy constructing who #" << id << "\n";
    }
    
    void show() {
        cout << "I am who #" << id << "\n";
    }
};

who make_who() {
    who temp('A');  // Local object
    return temp;    // Returns copy
}

int main() {
    cout << "=== Starting program ===\n";
    who obj = make_who();  // Assignment from returned object
    obj.show();
    cout << "=== Ending program ===\n";
    return 0;
}
```

**Expected Output Analysis:**
```
=== Starting program ===
Constructing who #A          // temp object created in make_who()
Copy constructing who #A     // temporary object created for return
Destroying who #A            // temp object destroyed (going out of scope)
Copy constructing who #A     // obj created from temporary
Destroying who #A            // temporary object destroyed
I am who #A
=== Ending program ===
Destroying who #A            // obj destroyed at program end
```

**What This Reveals:**
- Multiple objects created and destroyed during return process
- Temporary objects are invisible but real
- Understanding the lifecycle helps debug memory issues

### Exercise 2: Other Improper Return Scenarios

**Task:** Think of situations other than incorrect memory freeing where returning objects would be improper.

**Answer - Problematic Scenarios:**

#### 1. **File Handle Management**
```cpp
class FileHandler {
    FILE* file;
public:
    FileHandler(const char* filename) {
        file = fopen(filename, "r");
    }
    ~FileHandler() {
        if (file) fclose(file);  // Problem: Multiple close attempts
    }
};

FileHandler getFile() {
    FileHandler fh("data.txt");
    return fh;  // PROBLEM: File closed multiple times
}
```

#### 2. **Network Connection Management**
```cpp
class NetworkConnection {
    int socket_fd;
public:
    NetworkConnection() {
        socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    }
    ~NetworkConnection() {
        close(socket_fd);  // Problem: Socket closed multiple times
    }
};
```

#### 3. **Database Connection Management**
```cpp
class DatabaseConnection {
    void* db_handle;
public:
    DatabaseConnection() {
        db_handle = connect_to_database();
    }
    ~DatabaseConnection() {
        disconnect_database(db_handle);  // Problem: Multiple disconnects
    }
};
```

#### 4. **Thread/Mutex Management**
```cpp
class MutexWrapper {
    pthread_mutex_t mutex;
public:
    MutexWrapper() {
        pthread_mutex_init(&mutex, NULL);
    }
    ~MutexWrapper() {
        pthread_mutex_destroy(&mutex);  // Problem: Mutex destroyed multiple times
    }
};
```

#### 5. **Reference Counting Issues**
```cpp
class RefCountedResource {
    static int ref_count;
    SomeResource* resource;
public:
    RefCountedResource() {
        ref_count++;
        if (ref_count == 1) {
            resource = allocate_resource();
        }
    }
    ~RefCountedResource() {
        ref_count--;
        if (ref_count == 0) {
            deallocate_resource(resource);  // Problem: Incorrect count
        }
    }
};
```

**Common Pattern:**
All these scenarios involve **RAII (Resource Acquisition Is Initialization)** violations where:
- Constructor acquires a resource
- Destructor releases the resource
- Multiple destructor calls cause multiple resource releases
- No proper copy semantics implemented

---

## Solutions and Best Practices

### 1. **Avoid Returning Resource-Managing Objects**
```cpp
// Instead of returning the object, use parameters
void input(samp& result) {
    // Modify the passed object directly
}
```

### 2. **Implement Copy Constructor**
```cpp
class samp {
    char* s;
public:
    // Copy constructor for deep copy
    samp(const samp& other) {
        if (other.s) {
            s = (char*)malloc(strlen(other.s) + 1);
            strcpy(s, other.s);
        } else {
            s = nullptr;
        }
    }
};
```

### 3. **Use Smart Pointers (Modern C++)**
```cpp
#include <memory>
class samp {
    std::unique_ptr<char[]> s;
public:
    // Automatic proper copy/move semantics
};
```

### 4. **Return by Reference When Possible**
```cpp
samp& getSamp() {
    static samp instance;
    return instance;  // Return reference, not copy
}
```

---

## Summary

**Key Takeaways:**
1. **Temporary objects** are created when returning objects from functions
2. **Multiple destructor calls** occur: local object, temporary object, and final object
3. **Memory management** becomes critical with dynamic allocation
4. **Shallow copying** is the default behavior and often problematic
5. **Resource management** (files, sockets, memory) requires careful consideration
6. **Copy constructors** are essential for classes managing resources
7. **RAII violations** are common causes of return-related bugs

**Safe Return Guidelines:**
- Use objects with automatic storage only
- Implement proper copy constructors for resource-managing classes
- Consider returning references or using output parameters
- Be aware of the temporary object lifecycle
- Test thoroughly with resource-managing objects